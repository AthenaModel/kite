#-----------------------------------------------------------------------
# TITLE:
#   subtree_app.tcl
#
# AUTHOR:
#   Will Duquette
#
# DESCRIPTION:
#   Kite: kiteapp(n), "app" subtree writer: project files
#
#-----------------------------------------------------------------------

namespace eval ::kiteapp::subtree:: {
    namespace export \
        app
}

# app app
#
# app  - The app name
#
# Saves an application's files.

proc ::kiteapp::subtree::app {app} {
    treefile bin/$app.tcl [App_loader $app]
    pkg ${app}app main
}

# App_loader app
#
# app - The application name
#
# Returns the contents of the default app loader file.

codeblock ::kiteapp::subtree::App_loader {app} {
    set project [project name]
    set package ${app}app
} {
    #!/bin/sh
    # -*-tcl-*-
    # The next line restarts using tclsh \\
    exec tclsh "$0" "$@"

    #-----------------------------------------------------------------------
    # TITLE:
    #    %app.tcl
    #
    # PROJECT:
    #    %project
    #
    # DESCRIPTION:
    #    Application Launcher for %app
    #
    #    This script serves as the main entry point for the %app
    #    tool.  The tool is invoked using 
    #    the following syntax:
    #
    #        $ %app ?args....?
    #
    # TODO: Much of this boilerplate could be moved into kiteinfo(n).
    #
    #    Generated by Kite.
    #-----------------------------------------------------------------------

    #-----------------------------------------------------------------------
    # Set up the auto_path, so that we can find the correct libraries.  
    # In development, there might be directories loaded from TCLLIBPATH;
    # strip them out.

    # First, remove all TCLLIBPATH directories from the auto_path.

    if {[info exists env(TCLLIBPATH)]} {
        set old_path $auto_path
        set auto_path [list]

        foreach dir $old_path {
            if {$dir ni $env(TCLLIBPATH)} {
                lappend auto_path $dir
            }
        }
    }

    # Next, get the project library directories.  Whether we're
    # in a starkit or not, the libraries can be found relative to this
    # script file.

    set appdir  [file normalize [file dirname [info script]]]
    set libdir  [file normalize [file join $appdir .. lib]]

    # Add the project libs to the new lib path.
    set auto_path [linsert $auto_path 0 $libdir]

    #-----------------------------------------------------------------------
    # Next, require Tcl/Tk and other required packages.

    package require Tcl
    package require kiteinfo

    if {[kiteinfo gui %app]} {
        package require Tk
    }

    #-----------------------------------------------------------------------
    # Next, add any includes libraries to the auto_path.
    #
    # This presumes that the include follows the usual project tree, with
    # all Tcl packages in $root/lib/<package>.

    foreach iname [kiteinfo includes] {
        set idir [file join $appdir .. includes $iname lib]
        set auto_path [linsert $auto_path 0 [file normalize $idir]]
    }

    #-----------------------------------------------------------------------
    # NEXT, load the application code.

    package require %package
    namespace import %package::*

    #-----------------------------------------------------------------------
    # Main Program 
    #
    # FIXME: This routine should be defined in the %package(n) package.

    # main argv
    #
    # argv       Command line arguments
    #
    # This is the main program; it is invoked at the bottom of the file.
    # It determines the application to invoke, and does so.

    proc main {argv} {
        #===================================================================
        # FIXME

        puts "[kiteinfo project] [kiteinfo version]: [kiteinfo description]"
        puts ""
        hello $argv
        puts ""

        # FIXME
        #===================================================================
    }

    #-----------------------------------------------------------------------
    # Run the program

    try {
        # Allow for interactive testing
        if {!$tcl_interactive} {
            main $argv
        }
    } trap FATAL {result} {
        # A fatal application error; result is a message intended
        # for the user.
        puts $result
        puts ""
    } on error {result eopts} {
        # A genuine error; report it in detail.
        puts "Unexpected Error: $result"
        puts "\nStack Trace:\n[dict get $eopts -errorinfo]"
    }
}

