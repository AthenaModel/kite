<document "Kite Developer's Guide">

<swallow {
    proc root {{path ""}} {
        if {$path ne ""} {
            return "[tt][i root]/[expand $path][/tt]"
        } else {
            return "[tt][i root]/[/tt]"
        }
    }

    # <table ...>
    # <treedir path> Description </treedir>
    #    ...
    # </table>

    template treedir {path} {
        set trans {
            +   &nbsp;&nbsp;&nbsp;&nbsp; 
            (   <i> 
            )   </i>
        }

        set path [string map $trans  $path]
    } {
        |<--
        [tr]<td><b><tt>$path</tt></b></td>
        <td>
    }

    template /treedir {} {
        |<--
        </td>
        [/tr]
    }
}>

<hrule>

<contents>

<hrule>

<preface audience "Audience">

This guide is intended for the Kite developer, but may also be of use to
the Kite user as it documents Kite's expectations for the content of the
project tree.<p>

<hrule>

<section overview "Kite Overview">

<hrule>

<section projtree "The Project Tree">

A typical Kite project tree has some or all of the following parts.<p>

<table tab.projtree "Project Directory Tree">
<th><td>Path</td> <td>Description</td></th>

<treedir (root)/>       Root of the project tree</treedir>
<treedir +project.kite> <xref projfile "Kite Project File">
                        </treedir>
<treedir +bin/>         <xref app "Application"> loader scripts and 
                        ancillary tools.</treedir>
<treedir ++(name).tcl>  Application loader script for application <i name>.
                        </treedir>
<treedir +docs/>        <xref docs "Project documentation"></treedir>
<treedir ++man1/>       Man page section (1): Executables</treedir>
<treedir ++man5/>       Man page section (5): File Formats</treedir>
<treedir ++mann/>       Man page section (n): Tcl Commands</treedir>
<treedir ++mani/>       Man page section (i): Tcl Interfaces</treedir>
<treedir +lib/>         Tcl <xref lib "Library Packages"> </treedir>
<treedir ++(name)/>     Tcl source code for package
                        <i>name</i></treedir>
<treedir ++(name)app/>  Tcl source code for application <i name>.
                        </treedir>
<treedir +test/>        <xref testing "Project test suites">.  
                        <tt test/> directories are usually parallel to
                        <tt lib/> directories.</treedir>
<treedir ++(name)/>     Test suite for package <i>name</i></treedir>
<treedir +src/>         <xref comp "Compiled source directories"></treedir>
<treedir ++(name)/>     Compiled source directory <i>name</i></treedir>
<treedir +.kite/>       Kite transient data directory.</treedir>
</table><p>

The project <root> directory will frequently contain other files, e.g., 
<tt README> and <tt LICENSE> files, and of course other subdirectories may 
be added as needed.<p>

<section projtree.new "Creating New Project Trees">

It is possible to set up a Kite project tree by hand, but it is more 
usually to use the <tt kite new> command.  At present, <tt kite new>
supports three templates:<p>

<topiclist>
<topic "<b lib>"> 
A project that provides a Tcl library package for external use.
The project includes stub documentation and the package's 
<root lib/> and <root test/> directories.<p>
</topic>

<topic "<b app>">
A project that provides an application, delivered as a standalone executable
for the current platform.  The package includes the stub documentation,
the application's loader script (<root "bin/<i name>.tcl">), and an 
application implementation package called <tt><i name>app</tt>.  The 
package includes both <root lib/> and <root test/> directories.
The application's loader script calls the <tt main> command, which is
defined by the implementation package.<p>
</topic>

<topic "<b appkit>">
A project that provides an application, delivered as a "starkit".
The project tree's contents are the same as for the <b app> template.<p>
</topic>

</topiclist>

Other templates might be added over time, as well as support for
project template plugins.<p>

<section projtree.add "Adding Elements to a Project Tree">

The tree created by <tt kite new> is just a starting point;
additional elements can be added by hand, or by using <tt kite add>.<p>

At present, <tt kite add> supports two element templates:<p>

<topiclist>
<topic "<b lib>"> 
Adds a new library package called <i name> to the project tree, in the
form of the package's <root lib/> and <root test/> directories, and
updates the <xref projfile "project file"> accordingly.<p>
</topic>

<topic "<b app>">
Adds a new application package called <i name> to the project tree, 
including its loader script and its implementation package's  
<root lib/> and <root test/> directories, and
updates the <xref projfile "project file"> accordingly.<p>
</topic>

</topiclist>




<hrule>

<section projfile "The Project File">

<hrule>

<section lib "Library Packages">

Library packages are placed in subdirectories of the <root lib/> directory.
The directory name should match the package name, e.g., package 
<tt mylib> resides in <root {lib/mylib/}>.<p>

Each library package should define the files defined in the following
sections.<p>

<section lib.pkgindex "The 'pkgIndex.tcl' File">

Every package will have a <tt pkgIndex.tcl> file.  This file is usually 
created by <tt kite new> or <tt kite add>, but can be copied or created
by hand.  Every <tt pkgIndex.tcl> file should look more or less like
<xref fig.lib.pkgindex>.<p>

<textfigure fig.lib.pkgindex "Standard 'pkgIndex.tcl' File">
<listing>
#-------------------------------------------------------------------------
# TITLE:
#    pkgIndex.tcl
#
# PROJECT:
#    myproject - My Project Description
#
# DESCRIPTION:
#    mylib(n) package index file
#
#    Generated by Kite.
#-------------------------------------------------------------------------

# -kite-ifneeded-start <mark A> DO NOT EDIT THIS BLOCK BY HAND 
package ifneeded mylib 1.2.3 [list source [file join $dir pkgModules.tcl]] <mark B> 
# -kite-ifneeded-end <mark A>
</listing>

<topiclist>
<topic {<bigmark A>}>
These lines are Kite update marks.  They bracket code that Kite will update
or replace as the project metadata changes.  In this case, the code is
replaced altogether whenever the project's version number changes.<p>
</topic>

<topic {<bigmark B>}>
This is the <tt package ifneeded> command, which loads the package when
it is required by the application.  There are several things to notice about
this line:<p>

<ul>
<li> It loads the package by sourcing the <tt pkgModules.tcl> file.  This is
standard in Kite projects; see <xref lib.pkgmodules>.<p>

<li> It states the package version, "1.2.3" in this case.  The package's
version number should always match that of the project as a whole.<p>

<li> Kite keeps the version number up to date automatically.<p>
</topic>
</topiclist>

<b NOTE:> Kite rewrites the entire segment between the marks, so it will
always look exactly like this.  If you need something different, you can
remove the <tt kite-ifneeded> lines, but then you'll have to maintain
the version number yourself.<p>

<section lib.pkgmodules "The 'pkgModules.tcl' File">

The package's <tt pkgIndex.tcl> file always sources a file called 
<tt pkgModules.tcl>, which is responsible for loading the rest of the
package.  A typical <tt pkgModules.tcl> file is as follows:<p>

<textfigure fig.lib.pkgmodules "Standard 'pkgModules.tcl' file">
<listing>
#-----------------------------------------------------------------------
# TITLE:
#    pkgModules.tcl
#
# PROJECT:
#    myproject - My Project Description
#
# DESCRIPTION:
#    mylib(n) package modules file
#
#    Generated by Kite.
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Package Definition

# -kite-provide-start <mark A> DO NOT EDIT THIS BLOCK BY HAND
package provide mylib 1.2.3 <mark B>
# -kite-provide-end <mark A>

#-----------------------------------------------------------------------
# Required Packages

# -kite-require-start <mark C> ADD EXTERNAL DEPENDENCIES
package require snit 2.3 <mark D>
package require -exact myotherlib 1.2.3 <mark E>
# -kite-require-end <mark C>

#-----------------------------------------------------------------------
# Namespace definition

namespace eval ::mylib:: { <mark F>
    variable library [file dirname [info script]] <mark G>
}

#-----------------------------------------------------------------------
# Submodules
#
# Note: modules are listed in order of dependencies; be careful if you
# change the order!

source [file join $::mylib::library module1.tcl] <mark H>
source [file join $::mylib::library module2.tcl]
...
</listing>

<topiclist>
<topic "<bigmark A>">
These lines are Kite update marks.  They bracket code that Kite will
update or replace as the project metadata changes.  In this case, the 
code is replaced altogether whenever the package version number changes.<p>
</topic>

<topic "<bigmark B>">
This is the <tt package provide> command; it tells TCL the name and version
number of the provided package.  The package version number should always
match the project version number, and so Kite updates this block automatically
whenever the project version number changes.<p>
</topic>

<topic "<bigmark C>">
More Kite update marks.  Any <tt package require> statements found between
these marks that correspond to libraries either <tt require>'d or 
<tt provide>'d in the <xref projfile "project file"> will have their
version numbers updated.  Other lines will be left alone.  Note that 
the <tt package require> command must be the only thing on the line.<p>
</topic>

<topic "<bigmark D>">
This is an example of a package that is <tt require>'d in the 
project file.  Kite knows the desired version number, and will update this
line to include it.  If the <tt -exact> flag is included, Kite will 
preserve it.<p>
</topic>

<topic "<bigmark E>">
This is an example of a package that is <tt provide>'d by this same
project.  Because provided packages might be available in the local 
teapot (see <xref tbd>), Kite always includes the <tt -exact> flag;
together with control of the <tt auto_path>, this ensures that this
package will always load a consistent version of its sibling package 
in deployment, and the version in the same project tree during 
development.<p>
</topic>

<topic "<bigmark F>">
Every package gets a namespace with the same name.  It might or might
not put its code in that namespace (application implementation packages
often leave their code in the global namespace), but it's useful to 
always have a private namespace.<p>
</topic>

<topic "<bigmark G>">
Every package gets a variable called <tt library> in its private namespace.
This variable contains the path of the package's directory, whether it's
a normal disk directory or included in a virtual file system.  It's used
below when loading the package's modules, and it's also useful when loading
other package resources at run time.  If the package has data files or 
image files, the application can find them relative to 
<tt ::mylib::library>.<p>
</topic>

<topic "<bigmark H>">
Finally, the package's modules are loaded in any logical sequence.  The
idiom shown here, using <tt file join> with the package's 
<tt library> variable, is guaranteed to work on every platform.<p>
</topic>

</topiclist>

<section lib.onemodule "Packages with One Module">

If the package consists of only one module, it might be tempting to
have <tt pkgIndex.tcl> load that module directly.  Resist this temptation;
Kite will not be able to update the provided and required version numbers
properly.<p>

Similarly, if the package needs only one module it might be tempting to just
put the module's code at the end of <tt pkgModules.tcl> instead of in its
own file.  Resist this temptation as well.<p>

<section lib.modules "Package Modules">

A package module file can contain whatever TCL code you like; it's entirely
up to you.  A typical module looks like this:<p>

<textfigure fig.lib.module "A Typical Package Module">
<listing>
#-----------------------------------------------------------------------
# TITLE:
#    mymodule.tcl
#
# PROJECT:
#    myproject - My Project Description
#
# DESCRIPTION:
#    mylib(n) module: mymodule
#
#-----------------------------------------------------------------------

<mark A>

#-----------------------------------------------------------------------
# Exported commands

namespace eval ::mylib:: {
    namespace export myproc   <mark B>
}

#-----------------------------------------------------------------------
# Command Definitions

# myproc text
#
# text   - A block of text
#
# Does something to the block of text.

proc ::mylib::myproc {text} { <mark C>
    # Whatever you like.
}
</listing>

In general, a package module contains whatever code you need it to contain.<p>

<topiclist>
<topic "<bigmark A>">
Note that the module doesn't call either <tt package provide> or 
<tt package require>.  That's the job of the <tt pkgModules.tcl> file.<p>
</topic>

<topic "<bigmark B>">
You don't need to put your code in the package namespace; but if you do,
you might want to export some commands.<p>
</topic>

<topic "<bigmark C>">
You'll have to write this yourself.<p>
</topic>

</topiclist>

<hrule>

<section app "Applications">

<hrule>

<section testing "Project Test Suites">

Here's a sample listing:

<textfigure fig.all_tests "Sample 'all_tests.test' File">
<listing>
# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    all_tests.test
#
# PROJECT:
#    athena-mars
#
# DESCRIPTION:
#    kiteutils(n) test suite: all tests
#
#    Generated by Kite from all_tests.template.
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Initialize tcltest(n)

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2.2 
    eval ::tcltest::configure $argv
}

::tcltest::configure \
    -testdir [file dirname [file normalize [info script]]] \
    -notfile all_tests.test

#-----------------------------------------------------------------------
# Run all of the tests in this directory

::tcltest::runAllTests
</listing>

<hrule>

<section docs "Documentation Tools">

<hrule>

<section dep "Dependency Management">

A Kite project can have the following kinds of external dependency:<p>

<ul>
<li> Teapot packages
    <ul>
    <li> From remote teapot repository
    <li> Locally built and installed
    </ul>
<li> Basekits
    <ul>
    <li> For the current platform
    <li> With and without Tk
    </ul>
</ul><p>

<section dep.teapot "Teapot Packages">

A teapot package is a Tcl package installed in a remote or local "teapot"
repository, using the teapot-related tools that ship with ActiveTcl.<p>

The user specifies dependencies on teapot packages in by adding 
<xref project(5) require>
statements to their <tt project.kite> file, e.g.,<p>

<example>
require snit 2.3
</example>

<section dep.teapot.remote "Retrieving Teapot Packages from Remote Repositories">

Projects will often require packages produced non-locally.  Kite will
attempt to retrieve these from a remote teapot repository, usually
<tt http://teapot.activestate.com>.  By default, every required package is
assumed to be non-local.<p>

Kite uses the <tt teacup> tool to retrieve remote packages; see 
<xref teapot> for details.<p>

<section dep.teapot.local "Locally-built Teapot Packages">

A project may depend on library packages produced by other local projects.
It will retrieve these from the local teapot, just as for other external 
packages, and will track whether the local teapot contains the required
versions.  However, it will never attempt to retrieve them from a remote
teapot repository; rather the developer ensure that they are installed
locally.<p>

To mark a package as locally produced, use the `-local` flag:<p>

<example>
require kitedocs 1.0.0 -local
</example>

<section dep.basekits "Basekits">

A basekit is a single-file Tcl interpreter that can be used as the 
"prefix" of a wrapped stand-alone executable.  As such, basekits are an 
implicit dependency of any project that builds stand-alone executables.<p>

ActiveState includes two basekits with the ActiveTcl installation, one that 
includes Tk and one that doesn't.  The non-Tk basekit is smaller, resulting
in smaller executables when Tk isn't required; but the distinction is
especially important on Windows systems, where Tk applications do not have
access to stdin, stdout, and stderr.<p>

At present, Kite is delivered as a .kit, and is run using the development
Tcl installation; and finds the basekits for the current system relative
to that Tcl installation.  This means that Kite can only build executables
for the specific platform on which it is running.<p>

Basekits can also be retrieved from 
<tt http://teapot.activestate.com> using the
<tt teacup> tool.  In the future, Kite may take advantage of this 
to support cross-platform builds.<p>

<section dep.basekits.locating "Locating Basekits">

ActiveState's basekits are distinguished by the following variables:<p>

<ul>
<li> Whether or not Tk is included.
<li> Whether the basekit supports multiple threads or not.
<li> The version of Tcl/Tk
<li> The platform for which it was built.
</ul>

<section dep.basekits.locating.dist "In ActiveTcl Distributions">

For basekits distributed with ActiveTcl, these features are represented
in the filename as follows:<p>

<tt>base-<i tcltk><i x.y>-[thread-]-<i platform>[.exe]</tt><p>

where <i tcltk> is either "<tt tcl>" or "<tt tk>", "<i x.y>" is the Tcl
version, "thread-" is present or not, and <i platform> is the build  
platform as returned by the standard Tcl <tt platform::identify> command.<p>

As of 2014, ActiveState's freely available builds of ActiveTcl 8.5 and 8.6
are all threaded, so the "<tt thread->" component can be assumed.<p>

On Windows and Linux, the basekits are installed into the same directory
as the <i tclsh> executable.  On OS X, at least as of ActiveTcl 8.6, the
basekits are installed in the <tt /Library/Tcl/basekits> directory.<p>

ActiveTcl generally also provides dynamic Tcl/Tk libraries, which have
the same base name as the basekit but a different file extension
(<tt .so>, <tt .dll>, or <tt .dylib>).  When looking for the basekit,
it's usually necessary to filter these out.<p>

<section dep.basekits.locating.teapot "In the Teapot">

Basekits can also be retrieved from the the remote teapot repository.  
Artifacts in the repository are identified by four components:<p>

<ul>
<li> The entity type, usually <tt package> or <tt application>.  For 
    basekits, this is always <tt application>.<p>

<li> The artifact's name.  For basekits, this will be either 
    <tt base-tcl-thread> or <tt base-tk-thread>.<p>

<li> The version.  This is an ActiveState version number, which is usually
    <i x.y.z.w.buildNum>, e.g., <tt 8.6.1.1.298358>.<p>

<li> The platform on which it was built, e.g., <tt win32-ix86>,
    <tt macosx10.5-i386-x86_64>, or <tt linux-glibc2.3-ix86>.<p>
</ul>

To pull down the desired basekit, then, it's generally necessary to
get a list of the available basekits and decide which one best fits the
desired version and current platform.  This can be tricky.  Windows and
Linux come in 32-bit and 64-bit flavors; and the 
<tt platform::identify> value for the development platform often won't 
exactly match that of the appropriate basekit.<p>

In general, then, follow these rules:<p>

<ul>
<li> Always look for an <tt application>.<p>

<li> For a console application, look for <tt base-tcl-thread>; for
    a GUI application, look for <tt base-tk-thread>.<p>

<li> For Tcl version <i>X.Y</i>, look for the largest version 
    (per <tt package vcompare>) that matches "X.Y*".<p>

<li> Match the platform as follows:
    <ul>
    <li> 32-bit Windows: "<tt win32-ix86>".
    <li> 64-bit Windows: "<tt win32-x86_64>".
    <li> 32-bit Linux: "<tt linux-*-ix86>".
    <li> 64-bit Linux: "<tt linux-*-x86_64>".
    <li> 64-bit Mac OSX: "<tt macosx*-x86_64>".
    </ul><p>
</ul>

Having selected these four components, you can retrieve the basekit as
follows:

<example>
$ teacup get --is application --output <i folder> \
    <i name> <i version> <i platform>
</example>

The basekit will be saved to the specified <i folder>, and will be called<p>

<tt>application-<i name>-<i version>-<i platform>[.exe]</tt><p>

<hrule>

<section comp "Compilation">

<hrule>

<section dist "Building Distributions">

<hrule>

<section teapot "Teapot Management">

</document>
