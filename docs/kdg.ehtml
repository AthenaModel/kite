<document "Kite Developer's Guide">

<swallow {
    proc root {{path ""}} {
        if {$path ne ""} {
            return "[tt][i root]/[expand $path][/tt]"
        } else {
            return "[tt][i root]/[/tt]"
        }
    }

    # <table ...>
    # <treedir path> Description </treedir>
    #    ...
    # </table>

    template treedir {path} {
        set trans {
            +   &nbsp;&nbsp;&nbsp;&nbsp; 
            (   <i> 
            )   </i>
        }

        set path [string map $trans  $path]
    } {
        |<--
        [tr]<td><b><tt>$path</tt></b></td>
        <td>
    }

    template /treedir {} {
        |<--
        </td>
        [/tr]
    }
}>

<hrule>

<contents>

<hrule>

<preface audience "Audience">

This guide is primarily intended for the Kite developer, as it documents
Kite's expectations for the structure and content of project directory 
trees; however, it should also be of use to the new Kite user who wants
to know what Kite does and how Kite projects work.

<hrule>

<section overview "Kite Overview">

Kite is a command-line tool for managing TCL/TK projects, formatting 
project HTML documentation, running tests, and automating builds.
For a general overview of Kite, see the 
<i><link kite.docx "Kite White Paper"></i>.  For specifics about the
Kite commands described in this document, including precise calling
syntax, use the "<tt kite help>" command.

<hrule>

<section projtree "The Project Tree">

A typical Kite project tree has some or all of the following parts.

<table tab.projtree "Project Directory Tree">
<tr><th>Path</th> <th>Description</th></tr>

<treedir (root)/>       Root of the project tree</treedir>
<treedir +project.kite> <xref projfile "Kite Project File">
                        </treedir>
<treedir +bin/>         <xref app "Application"> loader scripts and 
                        ancillary tools.</treedir>
<treedir ++(name).tcl>  Application loader script for application <i name>.
                        </treedir>
<treedir +docs/>        <xref docs "Project documentation"></treedir>
<treedir ++man1/>       Man page section (1): Executables</treedir>
<treedir ++man5/>       Man page section (5): File Formats</treedir>
<treedir ++mann/>       Man page section (n): Tcl Commands</treedir>
<treedir ++mani/>       Man page section (i): Tcl Interfaces</treedir>
<treedir +lib/>         Tcl <xref lib "Library Packages"> </treedir>
<treedir ++(name)/>     Tcl source code for package
                        <i>name</i></treedir>
<treedir ++app_(name)/> Tcl source code for application <i name>.
                        </treedir>
<treedir +test/>        <xref testing "Project test suites">.  
                        <tt test/> directories are usually parallel to
                        <tt lib/> directories.</treedir>
<treedir ++(name)/>     Test suite for package <i>name</i></treedir>
<treedir +src/>         <xref comp "Compiled source directories"></treedir>
<treedir ++(name)/>     Compiled source directory <i>name</i></treedir>
<treedir +.kite/>       Kite transient data directory.</treedir>
</table>

The project <root> directory will frequently contain other files, e.g., 
<tt README> and <tt LICENSE> files, and of course other subdirectories may 
be added as needed.

Things to note:

<ulp>
<li> The <tt project.kite> file contains all of the information Kite needs
     to know to perform project tasks.  See <xref projfile>.

<li> The <root src/> subdirectories are a place for C libraries or any 
     other code requiring a non-Kite compilation step.  See <xref comp>.
</ulp>

<section projtree.new "Creating New Project Trees">

It is possible to set up a Kite project tree by hand, but it is both more
usual and much easier to use the <tt kite new> command.  At present, 
<tt kite new> supports three templates:

<topiclist>
<topic [b lib]> 
A project that provides a Tcl library package for external use.
The project includes stub documentation and the package's 
<root lib/> and <root test/> directories.
</topic>

<topic [b app]>
A project that provides an application, delivered as a standalone executable
for the current platform.  The project tree includes the stub documentation,
the application's loader script (<root "bin/<i name>.tcl">), and an 
application implementation package called <tt>app_<i name></tt>.  The 
package includes both <root lib/> and <root test/> directories.
The application's loader script calls the <tt main> command, which is
defined by the <tt>app_<i name></tt> implementation package.
</topic>

<topic [b appkit]>
A project that provides an application, delivered as a "starkit".
The project tree's contents are the same as for the <b app> template.
This template is useful for tools that will run only in the development
environment.
</topic>

</topiclist>

Other templates might be added over time, as well as support for
project template plugins.

<section projtree.add "Adding Elements to a Project Tree">

The tree created by <tt kite new> is just a starting point;
additional elements can be added by hand, or by using <tt kite add>.

At present, <tt kite add> supports two element templates:

<topiclist>
<topic [b lib]> 
Adds a new library package called <i name> to the project tree, in the
form of the package's <root lib/> and <root test/> directories, and
adds a <tt provide> statement to the <xref projfile "project file">.  If
the library is for internal use only, remove the <tt provide> statement.
</topic>

<topic [b app]>
Adds a new application package called <i name> to the project tree, 
including its loader script and its implementation package's  
<root lib/> and <root test/> directories, and
updates the <xref projfile "project file"> accordingly.
</topic>

</topiclist>

<hrule>

<section projfile "The Project File">

The Kite project file, <root project.kite>, is the equivalent of a set of
Makefiles for a C project or of a Maven file for Java projects.  It
contains all data about the project that the Kite executable needs to do
its job.  In particular, the project file specifies:

<ul>
<li> The project's name, version, and description
<li> The e-mail address of the primary point-of-contact
<li> The applications contained in the project
<li> The library packages provided by the project
<li> The external library packages required by the project
<li> Non-TCL project components that require compilation
<li> Content of distribution .zip files 
</ul>

The initial content of the project file is created by the 
<tt kite new> command when the project tree is first initialized, and 
extended by <tt kite add> as new components are added.  Other content is
added by the developer, by hand.

The project version is particularly important.  The version number
specified in the project file is available to all of the project's
applications at run time, and is embedded in every library package
provided for external use.

The syntax of the project file is defined in the 
<xref project(5)> man page.

<hrule>

<section lib "Library Packages">

This section describes the code layout for library packages in the project
tree.  Library packages usually also have test suites and man pages; see
<xref testing> and <xref docs> for details.

A library package's source code is placed in a subdirectory of the 
<root lib/> directory.  The directory name should match the package 
name, e.g., package <tt mylib> resides in <root {lib/mylib/}>.

Each library package should define the files defined in the following
sections.

<section lib.pkgindex "The 'pkgIndex.tcl' File">

Every package will have a <tt pkgIndex.tcl> file.  This file is usually 
created by <tt kite new> or <tt kite add>, but can be copied or created
by hand.  Every <tt pkgIndex.tcl> file should look more or less like
<xref fig.lib.pkgindex>.  User-provided content is shown in boldface.

<textfigure fig.lib.pkgindex "Standard 'pkgIndex.tcl' File">
<listing>
#-------------------------------------------------------------------------
# TITLE:
#    pkgIndex.tcl
#
# PROJECT:
#    <b myproject - My Project Description>
#
# DESCRIPTION:
#    <b mylib>(n) package index file
#
#    Generated by Kite.
#-------------------------------------------------------------------------

# -kite-ifneeded-start <mark A> DO NOT EDIT THIS BLOCK BY HAND 
package ifneeded <b mylib> 1.2.3 [list source [file join $dir pkgModules.tcl]] <mark B> 
# -kite-ifneeded-end <mark A>
</listing>

<topiclist>
<topic [mark A]>
These lines are Kite update marks.  They bracket code that Kite will update
or replace as the project metadata changes.  In this case, the code is
replaced altogether whenever the project's version number changes.
</topic>

<topic [mark B]>
This is the <tt package ifneeded> command, which loads the package when
it is required by the application.  There are several things to notice about
this line:

<ul>
<li> It loads the package by sourcing the <tt pkgModules.tcl> file.  This is
standard in Kite projects; see <xref lib.pkgmodules>.

<li> It states the package version, "1.2.3" in this case.  The package's
version number should always match that of the project as a whole.

<li> Kite keeps the version number up to date automatically.
</ul>
</topic>
</topiclist>

<b NOTE:> Kite rewrites the entire segment between the marks, so it will
always look exactly like this.  If you need something different, you can
remove the <tt kite-ifneeded> lines; but then you'll have to maintain
the version number yourself.

<section lib.pkgmodules "The 'pkgModules.tcl' File">

The package's <tt pkgIndex.tcl> file always sources a file called 
<tt pkgModules.tcl>, which is responsible for loading the rest of the
package.  A typical <tt pkgModules.tcl> file is as follows; user-provided
content is shown in bold.

<textfigure fig.lib.pkgmodules "Standard 'pkgModules.tcl' file">
<listing>
#-----------------------------------------------------------------------
# TITLE:
#    pkgModules.tcl
#
# PROJECT:
#    <b myproject - My Project Description>
#
# DESCRIPTION:
#    <b mylib(n)> package modules file
#
#    Generated by Kite.
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Package Definition

# -kite-provide-start <mark A> DO NOT EDIT THIS BLOCK BY HAND
package provide <b mylib> 1.2.3 <mark B>
# -kite-provide-end <mark A>

#-----------------------------------------------------------------------
# Required Packages

# -kite-require-start <mark C> ADD EXTERNAL DEPENDENCIES
<b>package require snit 2.3</b> <mark D>
<b>package require -exact myotherlib 1.2.3</b> <mark E>
# -kite-require-end <mark C>

#-----------------------------------------------------------------------
# Namespace definition

namespace eval ::<b mylib>:: { <mark F>
    variable library [file dirname [info script]] <mark G>
}

#-----------------------------------------------------------------------
# Submodules
#
# Note: modules are listed in order of dependencies; be careful if you
# change the order!

<b>source [file join $::mylib::library module1.tcl]</b> <mark H>
<b>source [file join $::mylib::library module2.tcl]</b>
<b>...</b>
</listing>

<topiclist>
<topic [mark A]>
These lines are Kite update marks.  They bracket code that Kite will
update or replace as the project metadata changes.  In this case, the 
code is replaced altogether whenever the package version number changes.
</topic>

<topic [mark B]>
This is the <tt package provide> command; it tells TCL the name and version
number of the provided package.  The package version number should always
match the project version number, and so Kite updates this block automatically
whenever the project version number changes.
</topic>

<topic [mark C]>
More Kite update marks.  Any <tt package require> statements found between
these marks that correspond to libraries either <tt require>'d or 
<tt provide>'d in the <xref projfile "project file"> will have their
version numbers updated.  Other lines will be left alone.  Note that 
the <tt package require> command must be the only thing on the line.
</topic>

<topic [mark D]>
This is an example of a package that is <tt require>'d in the 
project file.  Kite knows the desired version number, and will update this
line to include it.  If the <tt -exact> flag is included, Kite will 
preserve it.
</topic>

<topic [mark E]>
This is an example of a package that is <tt provide>'d by this same
project.  Because provided packages might be available in the local 
teapot (see <xref dep>), Kite always includes the <tt -exact> flag;
together with control of the <tt auto_path>, this ensures that this
package will always load a consistent version of its sibling package 
in deployment, and the version in the same project tree during 
development.
</topic>

<topic [mark F]>
Every package gets a namespace with the same name.  It might or might
not put its code in that namespace (application implementation packages
often leave their code in the global namespace), but it's useful to 
always have a private namespace.
</topic>

<topic [mark G]>
Every package gets a variable called <tt library> in its private namespace.
This variable contains the path of the package's directory, whether it's
a normal disk directory or included in a virtual file system.  It's used
below when loading the package's modules, and it's also useful when loading
other package resources at run time.  If the package has data files or 
image files, the application can find them relative to 
<tt ::mylib::library>.
</topic>

<topic [mark H]>
Finally, the package's modules are loaded in any logical sequence.  The
idiom shown here, using <tt file join> with the package's 
<tt library> variable, is guaranteed to work on every platform.
</topic>

</topiclist>

<section lib.modules "Package Modules">

A package module file can contain whatever TCL code you like; it's entirely
up to you.  A typical module looks like this:

<textfigure fig.lib.module "A Typical Package Module">
<listing>
#-----------------------------------------------------------------------
# TITLE:
#    mymodule.tcl
#
# PROJECT:
#    myproject - My Project Description
#
# DESCRIPTION:
#    mylib(n) module: mymodule
#
#-----------------------------------------------------------------------

<mark A>

#-----------------------------------------------------------------------
# Exported commands

namespace eval ::mylib:: {
    namespace export myproc   <mark B>
}

#-----------------------------------------------------------------------
# Command Definitions

# myproc text
#
# text   - A block of text
#
# Does something to the block of text.

proc ::mylib::myproc {text} { <mark C>
    # Whatever you like.
}
</listing>

In general, a package module contains whatever code you need it to contain.

<topiclist>
<topic [mark A]>
Note that the module doesn't call either <tt package provide> or 
<tt package require>.  That's the job of the <tt pkgModules.tcl> file.
</topic>

<topic [mark B]>
You don't need to put your code in the package namespace; but if you do,
you might want to export some commands.
</topic>

<topic [mark C]>
You'll have to write this yourself.
</topic>

</topiclist>

<section lib.otherfiles "Other Files">

A package can also contain data files or files in other languages
(e.g., SQL files).  These should also be placed in the package directory;
the package should find them using its package library variable.  For 
example, a module in the <tt mylib> package might load a file 
called <tt data.txt> using code like this:

<example>
set data [readfile [file join $::mylib::library data.txt]]
</example>

The <tt readfile> command is defined in the <xref kiteutils(n)> package.

<section lib.onemodule "Packages with One Module">

If the package consists of only one module, it might be tempting to
have <tt pkgIndex.tcl> load that module directly.  Resist this temptation;
Kite will not be able to update the provided and required version numbers
properly.

Similarly, if the package needs only one module it might be tempting to just
put the module's code at the end of <tt pkgModules.tcl> instead of in its
own file.  Resist this temptation as well.

<section lib.manymodules "Packages with Many Modules">

If a package has a large number of modules or data files, it can be useful 
to put related groups of files into subdirectories.  All such modules 
should be still be loaded by the package's 
<tt><xref lib.pkgmodules pkgModules.tcl></tt> file.


<hrule>

<section app "Applications">

An application is a TCL/TK program.  An application's code consists of
a loader script, which resides in the <root bin/> directory, 
and an implementation package.  The implementation package is structured 
in the same way as a normal <xref lib "library package"> but has 
additional files.

<section app.loader "Application Loader File">

Each application has a loader script: the script is called to invoke the
application.  It is placed in the <root bin/> directory, and its name
should match the application name, e.g., application <tt myapp>'s loader
file will be <root bin/myapp.tcl>.

The contents of the loader script is generated completely by Kite when
the application is added to the project, and is left alone thereafter.
Thus, it can safely be edited, but there is rarely any need to do so.

Here's a sample listing, explaining 
the contents of the loader script.

<textfigure fig.app_loader "Sample Application Loader Script">
<listing>
#!/bin/sh
# -*-tcl-*-
# The next line restarts using tclsh \
exec tclsh "$0" "$@" <mark A>

#-----------------------------------------------------------------------
# TITLE:
#    myapp.tcl
#
# PROJECT:
#    myapp
#
# DESCRIPTION:
#    Application Launcher for myapp
#
#    This script serves as the main entry point for the myapp
#    tool.  The tool is invoked using 
#    the following syntax:
#
#        $ myapp ?args....?
#
#    Generated by Kite.
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Set up the auto_path, so that we can find the correct libraries.  
# In development, there might be directories loaded from TCLLIBPATH;
# strip them out.

# First, remove all TCLLIBPATH directories from the auto_path.

if {[info exists env(TCLLIBPATH)]} { <mark B>
    set old_path $auto_path
    set auto_path [list]

    foreach dir $old_path {
        if {$dir ni $env(TCLLIBPATH)} {
            lappend auto_path $dir
        }
    }
}

# Next, get the project library directories.  Whether we're
# in a starkit or not, the libraries can be found relative to this
# script file.

set appdir  [file normalize [file dirname [info script]]]
set libdir  [file normalize [file join $appdir .. lib]]

# Add the project libs to the new lib path.
set auto_path [linsert $auto_path 0 $libdir] <mark C>

#-----------------------------------------------------------------------
# Next, require Tcl/Tk and other required packages.

package require Tcl <mark D>
package require kiteinfo <mark E>

if {[kiteinfo gui myapp]} { <mark F>
    package require Tk
}

#-----------------------------------------------------------------------
# NEXT, load the application code.  This should define the "main"
# command.

package require app_myapp <mark G>

#-----------------------------------------------------------------------
# Run the program

try {
    # Allow for interactive testing
    if {!$tcl_interactive} {
        main $argv <mark H>
    }
} trap FATAL {result} { <mark I>
    # A fatal application error; result is a message intended
    # for the user.
    puts $result
    puts ""
    exit 1
} on error {result eopts} { <mark J>
    # A genuine error; report it in detail.
    puts "Unexpected Error: $result"
    puts "\nStack Trace:\n[dict get $eopts -errorinfo]"
    exit 1
}
</listing>

<topiclist>
<topic [mark A]>
This is a standard header for executable TCL scripts.  If the file is
marked as executable by the operating system, then it can be used to
invoke the application directly during development.
</topic>

<topic [mark B]>
The <tt auto_path> variable gives TCL a list of directories in which
to find library packages.  The <tt tclsh> initializes the 
<tt auto_path> from a number of sources, one of each is the
<tt TCLLIBPATH> environment variable.

The <tt TCLLIBPATH> variable tells TCL where specifically to look for
locally installed library packages.  In our case, we want our application 
to find its packages in the project tree or in the local "teapot" (see
<xref dep>); the <tt TCLLIBPATH> is irrelevant at best and a fruitful
source of errors at worst.  Consequently, if it is set we remove all
of the directories it lists from the TCL <tt auto_path> list.
</topic>

<topic [mark C]>
Next, we add our project's <root lib/> directory to the <tt auto_path>
so that the application can find its packages.  The <root lib/> 
directory is found relative to the loader script.
</topic>

<topic [mark D]>
It isn't strictly necessary to require the "Tcl" package, but it is
good practice.
</topic>

<topic [mark E]>
The <tt kiteinfo> package is a part of the project that is generated
automatically by Kite.  It makes project metadata (such as the 
project version number) available to the project's applications.  We
require it automatically.
</topic>

<topic [mark F]>
And then, if the project metadata indicates that this is a GUI application
we require the Tk GUI toolkit automatically, prior to loading any of the
application code.
</topic>

<topic [mark G]>
Application <tt myapp>'s code is found in the implementation package
<tt app_myapp>, so we load that package.  This simply loads the code
into memory; it does not execute the application.
</topic>

<topic [mark H]>
Next we invoke the application code by passing the application's 
command-line arguments to a routine called <tt main>, which is defined
by the <tt app_myapp> package.

The check on the <tt \$tcl_interactive> variable means that we can 
load the application code into an interactive TCL shell for interactive
testing and debugging by sourcing 
the loader script; it will load the code but won't execute the application.
</topic>

<topic [mark I]>
If the application wishes to terminate due to an explicitly checked error
condition, it may do so by throwing an error with error code <b FATAL>.
The application will display the error message to the user, and terminate
itself cleanly.

Note that the error message will not be visible for wrapped
GUI applications on Windows; such applications should handle errors at the 
GUI level.
</topic>

<topic [mark J]>
This clause catches all other errors, which are 
by definition bugs or they would not have bubbled all the way up 
to this point.  Consequently, the loader outputs the error message
and a full stack trace as an aid to debugging.
</topic>

</topiclist>


<section app.pkgindex "The 'pkgIndex.tcl' File">

The application package's <tt pkgIndex.tcl> file is no different than
a library package's <tt pkgIndex.tcl> file. See <xref lib.pkgindex> for
an example.

<section app.pkgmodules "The 'pkgModules.tcl' File">

The application package's <tt pkgModules.tcl> file is no different
than a library package's <tt pkgModules.tcl> file.  See 
<xref lib.pkgmodules> for an example.

If the application requires specific packages other than Tcl, Tk,
<tt kiteinfo>, or the application package itself, the relevant 
<tt package require> and <tt namespace import> commands should be 
added to this file.

<section app.main "The 'main.tcl' File">

This is the application's true main program; it must define the command
<tt main>, which must take one argument, a list of command-line 
arguments.  Here's the default <tt main.tcl> file; it simply outputs
the project name, version, and description, and its command line 
arguments.

Simple applications will often be contained almost entirely in this
file; larger applications will frequently define a singleton object
called <tt app> in <root lib/app_myapp/app.tcl> and have <tt main>
simply call <tt app init>.

<textfigure fig.main_tcl "Sample 'main.tcl' File">
<listing>
#-----------------------------------------------------------------------
# TITLE:
#   main.tcl
#
# PROJECT:
#   myapp - Your project description
#
# DESCRIPTION:
#   app_myapp(n) Package, main module.
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Commands

# main argv
#
# argv  - Arguments
#
# Dummy example main proc.

proc main {argv} {
    puts "[kiteinfo project] [kiteinfo version]: [kiteinfo description]"
    puts ""
    puts "Arguments: "<lb>$argv<rb>"
}
</listing>

<section app.modules "Application Modules and Data Files">

The application implementation package can contain additional code
modules and data files, just as a library package can.

<hrule>

<section testing "Project Test Suites">

Kite supports automated project testing via its <b kite test> command.

In addition to its <root lib/> directory, every TCL package initialized by 
<tt kite new> and <tt kite add> has a <root test/> directory containing
its <b tcltest(n)> test suite.  (<b tcltest(n)> is an excellent unit test 
framework included with TCL/TK; see the TCL man pages for documentation.)
This includes application implementation packages as well as library
packages; it is common to test application code just like library code.

Each package test suite consists of a boilerplate file called
<tt all_tests.test> plus any number of module-specific test files.

<section testing.all_tests "The 'all_tests.test' File"> 

Here's a sample listing of a package's <tt all_tests.test> file.  
Kite uses this when running the package's test suite.  There is
rarely any need to modify this file.

<textfigure fig.all_tests "Sample 'all_tests.test' File">
<listing>
# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    all_tests.test
#
# PROJECT:
#    myproj - My TCL Project
#
# DESCRIPTION:
#    mylib(n) test suite: all tests
#
#    Generated by Kite from all_tests.template.
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Initialize tcltest(n)

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2.2 
    eval ::tcltest::configure $argv
}

::tcltest::configure \
    -testdir [file dirname [file normalize [info script]]] \
    -notfile all_tests.test

#-----------------------------------------------------------------------
# Run all of the tests in this directory

::tcltest::runAllTests
</listing>

<section testing.module_test "Module Test Files">

The test file for a module in a package is designed so that Kite can 
execute the entire package test suite all at once or one file at a time.
Thus, each file must load the package.

When the test directory is first populated, Kite creates a sample 
module test file like the following.  The developer should replace 
the single test in this file with tests for each of the module's
features.  Then, for subsequent modules the developer should use 
the first module's test file as a template.

<textfigure fig.module_test "Sample 'mymodule.test' File">
<listing>
# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    mymodule.test
#
# PROJECT:
#    myapp - Your project description
#
# DESCRIPTION:
#    mylib(n) test suite for main.tcl
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Initialize tcltest(n)

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2.2 
    eval ::tcltest::configure $argv
}

namespace import ::tcltest::test
 
#-----------------------------------------------------------------------
# Load the package to be tested

source ../../lib/mylib/pkgModules.tcl <mark A>
namespace import ::mylib::*           <mark B>

#-------------------------------------------------------------------
# Setup

# setup
#
# Set up for tests

proc setup {} { <mark C>
    # TBD
}

# cleanup
#
# Cleans up after a test.

proc cleanup {} { <mark D>
    # TBD
}


#-------------------------------------------------------------------
# dummy

test dummy-1.1 {Dummy} -setup { <mark E>
    setup
} -body {
    set result 0
} -cleanup {
    cleanup
} -result {1} <mark F>


#-------------------------------------------------------------------
# Cleanup

tcltest::cleanupTests
</listing>

<topiclist>
<topic [mark A]>
The package's code is sourced in explicitly.  This prevents the test suite
from accidently loading the package code from somewhere else (i.e., 
from the local teapot).
</topic>

<topic [mark B]>
The package's exported commands are automatically imported into the 
global namespace for convenience.  Note that each test file runs in its
own interpreter by default, so there's no worry about crosstalk from
one test file to the next.
</topic>

<topic [mark C]>
If tests share common setup code, it's customary to define a procedure
called <tt setup> to avoid duplicating the code.
</topic>

<topic [mark D]>
If tests share common cleanup code, it's customary to define a procedure
called <tt cleanup> to avoid duplicating the code.
</topic>

<topic [mark E]>
<b tcltest(n)> tests are defined using the <tt test> command.  See the 
<b tcltest(n)> man page for full details.  In this case, the test has a 
name ("<tt dummy-1.1>"), a description ("Dummy"), a test <tt -setup> clause
that simply calls <tt setup>, a <tt -body> which is the test proper, 
a <tt -cleanup> clause that simply calls <tt cleanup>, and an expected
<tt -result>.  The test passes if the <tt -body> returns the expected
result, and fails otherwise.
</topic>

<topic [mark F]>
In this case, the test fails; the <tt -body> returns 0, but the test
expects 1.  This is a gentle reminder to the developer to write proper
unit tests. 
</topic>
</topiclist>

<section testing.ted "Test Execution Deputies">

Sometimes, and especially in application implementation packages, there
will be test setup and utility code shared across two or more test files.
In this case it is customary to place this code in a file called 
<root test/mylib/ted.tcl> and source it into each test script.  The
name <tt ted.tcl> stands for "Test Execution Deputy", and is a tribute
to Ted Brunzie, Athena's original test engineer.

The code in <root test/mylib/ted.tcl> should reside in the 
<tt ::ted> namespace, so as not to collide with the package definitions.

<hrule>

<section docs "Documentation Tools">

Kite supports two kinds of HTML documentation: man pages and 
section-numbered documents like this one.  Man pages are used to 
document executables, TCL APIs, file formats, and the like; 
section-numbered documents are used for other kinds of development
documentation.  Both are written in flavors of a markup language called
"Extended HTML", which is defined by the <xref ehtml(5)> man page.  The
man page-specific flavor is described in the <xref manpage(5)> man page,
and the document flavor is described in the <xref kitedoc(5)> man page.

The <b kite docs> command automatically translates the extended
HTML input files into standard HTML files:

<ulp>
<li> Files matching <root docs/*.ehtml> are assumed to be 
     <xref kitedoc(5)> files.

<li> Files matching <root docs/man1/*.ehtml> are assumed to be
     <xref manpage(5)> files documenting executables.

<li> Files matching <root docs/man5/*.ehtml> are assumed to be
     <xref manpage(5)> files documenting file formats.

<li> Files matching <root docs/mann/*.ehtml> are assumed to be
     <xref manpage(5)> files documenting TCL APIs.

<li> Files matching <root docs/mani/*.ehtml> are assumed to be
     <xref manpage(5)> files documenting interfaces implemented
     by multiple TCL APIs.
</ulp>

Additional man page sections can be used by adding the 
<xref project(5) mansec> statement to the 
<xref projfile "project file">.

Each <tt .ehtml> input file is translated into a matching <tt .html> 
file in the same directory.

There are examples of both kinds of document in Kite's own 
<root docs/> directory.

<hrule>

<section dep "Dependency Management">

A Kite project can have the following kinds of external dependency:

<ul>
<li> Teapot packages
    <ul>
    <li> From a remote teapot repository
    <li> Locally built and installed
    </ul>
<li> Basekits
    <ul>
    <li> For the current platform
    <li> With and without Tk
    </ul>
</ul>

<section dep.teapot "Teapot Repositories and Packages">

A <i teapot> is a kind of TCL/TK code repository defined by ActiveState for
use with their ActiveTcl distribution of TCL/TK.  A teapot can contain
multiple distinct versions of any number of TCL packages.

When ActiveTcl is installed, it defines a local teapot, which it
populates with a small number of popular packages.  The <tt tclsh>
application is linked to this local teapot; packages in the teapot
can be loaded using the <tt package require> command without any need to
set Tcl's <tt auto_path>.

ActiveTcl also maintains a remote teapot at 
<tt http://teapot.activestate.com> that contains a great many more
packages.  These packages may be installed into the local teapot using
a program called <tt teacup>, which is delivered with ActiveTcl.  This
is the usual way of acquiring third party packages.

The one difficult with this system is that ActiveTcl's local teapot is
usually stored in a part of the file system that normal users have no
write-access to; this makes it much harder to install new packages.

Kite works around this by creating its own local teapot in the user's 
home directory, as <tt ~/.kite/teapot>, and linking this local teapot
to the <tt tclsh>.  Packages can now be downloaded from the remote
teapot server and installed freely.

And then Kite goes one further.  When a Kite project provides a library
package for external use, Kite can wrap the library package as a teapot 
package and install it into the local teapot.  This makes the package
accessible by any of the user's TCL scripts.

<section dep.teapot.package "Required Packages">

Kite handles virtually all of the teapot details automatically.  To 
make use of an external TCL package, add a <xref project(5) require>
statement to the <xref projfile "project file">.  For example, to 
add a dependency on the Snit object system, add this line:

<example>
require snit 2.3
</example>

This tells Kite that your project will make need of Snit version 2.3.  This
has three effects:

<ulp>
<li> Kite will not build an executable if Snit is not available.
<li> The <tt kite deps update> command will pull Snit 2.3 (and any other
     dependencies) down from the remote teapot and install them in the
     local teapot.
<li> The "<tt package require snit>" statements in your packages' 
     <tt pkgModules.tcl> files will have their version numbers updated
     automatically if they change.
</ulp>

<section dep.teapot.local "Locally-built Teapot Packages">

A project may depend on library packages produced by other local projects.
It will retrieve these from the local teapot, just as for other external 
packages, and will track whether the local teapot contains the required
versions.  However, it will never attempt to retrieve them from a remote
teapot repository; rather the developer must ensure that they are installed
locally.

To mark a package as locally produced, use the `-local` flag:

<example>
require kiteutils 0.5.0 -local
</example>

<section dep.basekits "Basekits">

A basekit is a single-file Tcl interpreter that can be used as the 
"prefix" of a wrapped stand-alone executable.  As such, basekits are an 
implicit dependency of any project that builds stand-alone executables.

ActiveState includes two basekits with the ActiveTcl installation, one that 
includes Tk and one that doesn't.  The non-Tk basekit is smaller, resulting
in smaller executables when Tk isn't required; but the distinction is
especially important on Windows systems, where Tk applications do not have
access to stdin, stdout, and stderr, and on "headless" Linux nodes in the
cloud, where the X Windows libraries are not installed.

Kite always uses the basekits included in the development Tcl installation.
This means that Kite can only build executables for the specific platform 
on which it is running.

Basekits can also be retrieved from 
<tt http://teapot.activestate.com> using the
<tt teacup> tool.  In the future, Kite may take advantage of this 
to support cross-platform builds.

<section dep.basekits.locating "Locating Basekits">

ActiveState's basekits are distinguished by the following variables:

<ul>
<li> Whether or not Tk is included.
<li> Whether the basekit supports multiple threads or not.
<li> The version of Tcl/Tk
<li> The platform for which it was built.
</ul>

<section dep.basekits.locating.dist "In ActiveTcl Distributions">

For basekits distributed with ActiveTcl, these features are represented
in the filename as follows:

<tt>base-<i tcltk><i x.y>-[thread-]-<i platform>[.exe]</tt>

where <i tcltk> is either "<tt tcl>" or "<tt tk>", "<i x.y>" is the Tcl
version, "thread-" is present or not, and <i platform> is the build  
platform as returned by the standard Tcl <tt platform::identify> command.

As of 2014, ActiveState's freely available builds of ActiveTcl 8.5 and 8.6
are all threaded, so the "<tt thread->" component can be assumed.

On Windows and Linux, the basekits are installed into the same directory
as the <i tclsh> executable.  On OS X, at least as of ActiveTcl 8.6, the
basekits are installed in the <tt /Library/Tcl/basekits> directory.

ActiveTcl generally also provides dynamic Tcl/Tk libraries, which have
the same base name as the basekit but a different file extension
(<tt .so>, <tt .dll>, or <tt .dylib>).  When looking for the basekit,
it's usually necessary to filter these out.

<section dep.basekits.locating.teapot "In the Teapot">

Basekits can also be retrieved from the the remote teapot repository.  
Artifacts in the repository are identified by four components:

<ul>
<li> The entity type, usually <tt package> or <tt application>.  For 
    basekits, this is always <tt application>.

<li> The artifact's name.  For basekits, this will be either 
    <tt base-tcl-thread> or <tt base-tk-thread>.

<li> The version.  This is an ActiveState version number, which is usually
    <i x.y.z.w.buildNum>, e.g., <tt 8.6.1.1.298358>.

<li> The platform on which it was built, e.g., <tt win32-ix86>,
    <tt macosx10.5-i386-x86_64>, or <tt linux-glibc2.3-ix86>.
</ul>

To pull down the desired basekit, then, it's generally necessary to
get a list of the available basekits and decide which one best fits the
desired version and current platform.  This can be tricky.  Windows and
Linux come in 32-bit and 64-bit flavors; and the 
<tt platform::identify> value for the development platform often won't 
exactly match that of the appropriate basekit.

In general, then, follow these rules:

<ul>
<li> Always look for an <tt application>.

<li> For a console application, look for <tt base-tcl-thread>; for
    a GUI application, look for <tt base-tk-thread>.

<li> For Tcl version <i>X.Y</i>, look for the largest version 
    (per <tt package vcompare>) that matches "X.Y*".

<li> Match the platform as follows:
    <ul>
    <li> 32-bit Windows: "<tt win32-ix86>".
    <li> 64-bit Windows: "<tt win32-x86_64>".
    <li> 32-bit Linux: "<tt linux-*-ix86>".
    <li> 64-bit Linux: "<tt linux-*-x86_64>".
    <li> 64-bit Mac OSX: "<tt macosx*-x86_64>".
    </ul>
</ul>

Having selected these four components, you can retrieve the basekit as
follows:

<example>
$ teacup get --is application --output <i folder> \
    <i name> <i version> <i platform>
</example>

The basekit will be saved to the specified <i folder>, and will be called

<tt>application-<i name>-<i version>-<i platform>[.exe]</tt>

<hrule>

<section comp "Compilation">

Kite handles many tasks automatically.  It can format documentation,
run test suites, wrap libraries as teapot packages, and wrap applications
as single-file executables.  But there are many tasks it cannot do itself;
for example, it cannot compile C code and link it into a library.

Kite supports this kind of compilation via the <xref project(5) src>
statement in the <xref projfile "project file"> and the
<root src/> directory.

Suppose you have some code that needs to be compiled.  Put it into
a subdirectory of <root src/>, say, <root src/myclib>.  Include a
<tt Makefile> that supports two targets, <tt make all> and 
<tt make clean>.

Then, add the following statement to the <xref projfile "project file">:

<example>
src myclib
</example>

The <b kite compile> and <b kite build> commands will now call the
<tt Makefile> at the appropriate time.

If the commands <tt make clean> and <tt make all> are not appropriate,
they can be customized using the <xref project(5) src> statement's 
options.  See <xref project(5)> for more details, and also for a 
discussion of what to do if the C code being compiled is a binary
TCL extension.

Note that any kind of processing can be done in a 
<root src/> subdirectory; it need not be "compilation" per se.

<hrule>

<section dist "Building Distributions">

The final part of the build process is building the distribution files.
Kite directly supports the building of any number of 
distribution <tt .zip> files by
means of the <xref project(5) dist> statement in the 
<xref projfile "project file">.  The <xref project(5) dist> statement
gives the name of the distribution as well as a list of file patterns;
all files matching the patterns are pulled into the distribution file.
See <xref project(5)> for more details.

Distribution files are built by <b kite dist>, and implicitly
by <b kite build>.

Note that Kite does not build installers, just .zip files.  If you
wish a proper installer, you will need to find an installer builder
that suits your needs.  (Inno Setup works quite well for Windows.)

<section install "Local Installation">

Once a project has been built, it is often desirable to install its 
build projects for local use.  The <b kite install> command installs
the project's applications into the user's <tt ~/bin> directory, and
its provided packages into Kite's local teapot.

</document>
